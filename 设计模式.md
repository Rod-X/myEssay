## 前言

> 设计模式定义：面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
>
> 通俗来说，就是可重复使用的特定场景的特定解决方案

### js面向对象三大特性

封装，继承，多态

### js同时还是动态类型语言

动态类型：运行时，待变量被赋值后，才具备某种类型

静态类型：编译阶段，已经确认了变量的类型

### 鸭子类型(duck typing)

如果它走起路来像鸭子，叫起来也是鸭子，那么它就鸭子。

### 多态(polymorphism)

意思：多种对象，多种状态，也就是多态性
多态的作用：通过把状态赋予对象，消除操作上特定的条件分支语句，使得操作更加简洁优雅

```js
    //实例代码
    // 一个方法makeSound
    const makeSound = function(animal){
        if(animal instanceof Duck){
            console.log('嘎嘎嘎')
        }
        if(animal instanceof Mouse){
        console.log('吱吱吱')
        }
    }
    function Duck(){}
    function Mouse(){}
    makeSound(new Duck()) // '嘎嘎嘎'
    makeSound(new Mouse()) // '吱吱吱



    const makeSound = function(animal){
        if (animal.sound) {
          animal.sound()
        }else{
          console.log('---');
        }
    }
    function Duck(){}
    Duck.prototype.sound = ()=>console.log('嘎嘎嘎')
    function Mouse(){}
    Mouse.prototype.sound = ()=>console.log('吱吱吱')
    makeSound(new Duck()) // '嘎嘎嘎'
    makeSound(new Mouse()) // '吱吱吱
```

### 封装

> 封装包括：封装数据，封装实现，封装类型，封装变化
>
> 封装的最终目的是：隐藏-隐藏对象类型-隐藏实现细节-隐藏设计细节等

#### 封装实现

对象：对象对自己的行为负责，其他对象或者用户不需要关心它的内部，对象之间只通过暴露的API接口来通信。当我们修改一个对象时，随意修改，只要对外接口没有变化，就不会影响程序的其他功能。对象之间的耦合变的松散

#### 封装类型

通过抽象的类和接口，把对象真正类型隐藏再抽象类和接口中，同时把客户更关心的对象的行为暴露出去

（主要是ts实现，如装饰器）

#### 封装变化

封装在设计模式中，重心是体现为封装变化

封装变化的思维：怎么样才能在不重新设计的情况下进行变化

找到这些特定问题或场景的变化，将它封装起来，同时也体现了可复用

### 继承

就是存在在父对象的前提下，生成的子对象会拥有父对象的所有属性和方法，也拥有直接的属性和方法

javascript设计之初，是不存在类的概念，所以不能像c++/java这些语言一样，可以通过类创造和实现直接继承

所以诞生出，原型模式,组合模式等方式实现js的继承

## 1.原型模式

> 原型模式是创建对象的一种模式。
>
> 如果我们想要创建一个对象，一种方法时先指定它的类型，然后通过这类创建这个对象。
>
> 原型模式选择了另一种方式，我们不再关心对象的具体类型，而是找到一个对象，通过克隆来创建一个一模一样的对象
>
> 原型模式实现的关键是：语言本身是否提供了clone方法，es5提供了`Object.create`方法可以用来克隆对象

```javascript
    function Plane() {
      this.blood = 100
      this.attackLevel = 1
      this.defenseLevel = 1
    }
    var plane = new Plane()
    plane.blood = 500
    plane.attackLevel = 3
    plane.defenseLevel = 3
    var clonePlane = Object.create(plane)
    console.log(clonePlane);

	//create实现原理，是通过临时创建一个Fn，将Fn的prototype属性指向克隆对象本身。然后返回 new Fn()
	// 下面是简单实现
    function myCreate(obj) {
      function fn() {}
      fn.prototype = obj
      return new fn()
    }
```





