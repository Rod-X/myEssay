## 前言

> 设计模式定义：面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
>
> 通俗来说，就是可重复使用的特定场景的特定解决方案

### js面向对象三大特性

封装，继承，多态

### js同时还是动态类型语言

动态类型：运行时，待变量被赋值后，才具备某种类型

静态类型：编译阶段，已经确认了变量的类型

### 鸭子类型(duck typing)

如果它走起路来像鸭子，叫起来也是鸭子，那么它就鸭子。

### 多态(polymorphism)

意思：多种对象，多种状态，也就是多态性
多态的作用：通过把状态赋予对象，消除操作上特定的条件分支语句，使得操作更加简洁优雅

```js
    //实例代码
    // 一个方法makeSound
    const makeSound = function(animal){
        if(animal instanceof Duck){
            console.log('嘎嘎嘎')
        }
        if(animal instanceof Mouse){
        console.log('吱吱吱')
        }
    }
    function Duck(){}
    function Mouse(){}
    makeSound(new Duck()) // '嘎嘎嘎'
    makeSound(new Mouse()) // '吱吱吱



    const makeSound = function(animal){
        if (animal.sound) {
          animal.sound()
        }else{
          console.log('---');
        }
    }
    function Duck(){}
    Duck.prototype.sound = ()=>console.log('嘎嘎嘎')
    function Mouse(){}
    Mouse.prototype.sound = ()=>console.log('吱吱吱')
    makeSound(new Duck()) // '嘎嘎嘎'
    makeSound(new Mouse()) // '吱吱吱
```

### 封装

> 封装包括：封装数据，封装实现，封装类型，封装变化
>
> 封装的最终目的是：隐藏-隐藏对象类型-隐藏实现细节-隐藏设计细节等

#### 封装实现

对象：对象对自己的行为负责，其他对象或者用户不需要关心它的内部，对象之间只通过暴露的API接口来通信。当我们修改一个对象时，随意修改，只要对外接口没有变化，就不会影响程序的其他功能。对象之间的耦合变的松散

#### 封装类型

通过抽象的类和接口，把对象真正类型隐藏再抽象类和接口中，同时把客户更关心的对象的行为暴露出去

（主要是ts实现，如装饰器）

#### 封装变化

封装在设计模式中，重心是体现为封装变化

封装变化的思维：怎么样才能在不重新设计的情况下进行变化

找到这些特定问题或场景的变化，将它封装起来，同时也体现了可复用

### 继承

就是存在在父对象的前提下，生成的子对象会拥有父对象的所有属性和方法，也拥有直接的属性和方法

javascript设计之初，是不存在类的概念，所以不能像c++/java这些语言一样，可以通过类创造和实现直接继承

所以诞生出，原型模式,组合模式等方式实现js的继承

## 1.原型模式

> 原型模式是创建对象的一种模式。
>
> 如果我们想要创建一个对象，一种方法时先指定它的类型，然后通过这类创建这个对象。
>
> 原型模式选择了另一种方式，我们不再关心对象的具体类型，而是找到一个对象，通过克隆来创建一个一模一样的对象
>
> 原型模式实现的关键是：语言本身是否提供了clone方法，es5提供了`Object.create`方法可以用来克隆对象

原型模式的基本规则：

1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
   + 对象会记住他的原型
   + 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型

```javascript
    function Plane() {
      this.blood = 100
      this.attackLevel = 1
      this.defenseLevel = 1
    }
    var plane = new Plane()
    plane.blood = 500
    plane.attackLevel = 3
    plane.defenseLevel = 3
    var clonePlane = Object.create(plane)
    console.log(clonePlane.blood);// 找到clonePlane的原型并把获取blood属性的请求委托给它自己的原型

	//create实现原理，是通过临时创建一个Fn，将Fn的prototype属性指向克隆对象本身。然后返回 new Fn()
	// 下面是简单实现
    function myCreate(obj) {
      function fn() {}
      fn.prototype = obj
      return new fn()
    }
```

### 高阶函数

+ 函数作为参赛传入
+ 函数作为返回值输出

### AOP面向切面编程

AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块

### 函数柯里化Currying

一个currying函数首先会接收一些参数，接收了这些残守之后，该函数并不会立即求职，而是继续返回另一个函数，刚才传入的参数在函数形成闭包中被保存起来。待到函数被真正需要求值时，之前传入的所有参数会被一次性用于求值

### 函数节流

函数被频繁触发，而我们不需要它那么高频的触发，所以我们要使它节流，就是把触发频率变低，变为我们规定的一定时间内触发一次。

```javascript
  window.onload = function () {
    let throttle = function (fn, interval = 500) {
      let selt = fn // 存储函数
      let isFirst = true //是否为第一次触发
      let timer = null
      return function (...args) {
        let context = this
        if (isFirst) {
          fn.apply(context, args)
          isFirst = false
          return
        }
        if (timer) {
          return
        } else {
          timer = setTimeout(() => {
            fn.apply(context, args)
            clearTimeout(timer)
            timer = null
          }, interval);
        }
      }
    }
    function onsizeFn() {
      console.log(this, 'onsizeFn');
    }
    function ThrottleOnsizeFn() {
      console.log(this, 'ThrottleOnsizeFn');
    }
    let mydiv = document.getElementById('mydiv')
    for (let index = 0; index < 100; index++) {
      let div = document.createElement('div')
      div.innerHTML = `这是第${index}个div`
      mydiv.appendChild(div)
    }
    window.addEventListener('resize', onsizeFn)
    window.addEventListener('resize', throttle(ThrottleOnsizeFn))
  }
```



