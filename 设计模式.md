## 前言

> 设计模式定义：面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。
>
> 通俗来说，就是可重复使用的特定场景的特定解决方案

### js面向对象三大特性

封装，继承，多态

### js同时还是动态类型语言

动态类型：运行时，待变量被赋值后，才具备某种类型

静态类型：编译阶段，已经确认了变量的类型

### 鸭子类型(duck typing)

如果它走起路来像鸭子，叫起来也是鸭子，那么它就鸭子。

### 多态(polymorphism)

意思：多种对象，多种状态，也就是多态性
多态的作用：通过把状态赋予对象，消除操作上特定的条件分支语句，使得操作更加简洁优雅

```js
    //实例代码
    // 一个方法makeSound
    const makeSound = function(animal){
        if(animal instanceof Duck){
            console.log('嘎嘎嘎')
        }
        if(animal instanceof Mouse){
        console.log('吱吱吱')
        }
    }
    function Duck(){}
    function Mouse(){}
    makeSound(new Duck()) // '嘎嘎嘎'
    makeSound(new Mouse()) // '吱吱吱



    const makeSound = function(animal){
        if (animal.sound) {
          animal.sound()
        }else{
          console.log('---');
        }
    }
    function Duck(){}
    Duck.prototype.sound = ()=>console.log('嘎嘎嘎')
    function Mouse(){}
    Mouse.prototype.sound = ()=>console.log('吱吱吱')
    makeSound(new Duck()) // '嘎嘎嘎'
    makeSound(new Mouse()) // '吱吱吱
```

### 封装

> 封装包括：封装数据，封装实现，封装类型，封装变化
>
> 封装的最终目的是：隐藏-隐藏对象类型-隐藏实现细节-隐藏设计细节等

#### 封装实现

对象：对象对自己的行为负责，其他对象或者用户不需要关心它的内部，对象之间只通过暴露的API接口来通信。当我们修改一个对象时，随意修改，只要对外接口没有变化，就不会影响程序的其他功能。对象之间的耦合变的松散

#### 封装类型

通过抽象的类和接口，把对象真正类型隐藏再抽象类和接口中，同时把客户更关心的对象的行为暴露出去

（主要是ts实现，如装饰器）

#### 封装变化

封装在设计模式中，重心是体现为封装变化

封装变化的思维：怎么样才能在不重新设计的情况下进行变化

找到这些特定问题或场景的变化，将它封装起来，同时也体现了可复用

### 继承

就是存在在父对象的前提下，生成的子对象会拥有父对象的所有属性和方法，也拥有直接的属性和方法

javascript设计之初，是不存在类的概念，所以不能像c++/java这些语言一样，可以通过类创造和实现直接继承

所以诞生出，原型模式,组合模式等方式实现js的继承

## 1.原型模式

> 原型模式是创建对象的一种模式。
>
> 如果我们想要创建一个对象，一种方法时先指定它的类型，然后通过这类创建这个对象。
>
> 原型模式选择了另一种方式，我们不再关心对象的具体类型，而是找到一个对象，通过克隆来创建一个一模一样的对象
>
> 原型模式实现的关键是：语言本身是否提供了clone方法，es5提供了`Object.create`方法可以用来克隆对象

原型模式的基本规则：

1. 所有的数据都是对象
2. 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它
   + 对象会记住他的原型
   + 如果对象无法响应某个请求，它会把这个请求委托给它自己的原型

```javascript
    function Plane() {
      this.blood = 100
      this.attackLevel = 1
      this.defenseLevel = 1
    }
    var plane = new Plane()
    plane.blood = 500
    plane.attackLevel = 3
    plane.defenseLevel = 3
    var clonePlane = Object.create(plane)
    console.log(clonePlane.blood);// 找到clonePlane的原型并把获取blood属性的请求委托给它自己的原型

	//create实现原理，是通过临时创建一个Fn，将Fn的prototype属性指向克隆对象本身。然后返回 new Fn()
	// 下面是简单实现
    function myCreate(obj) {
      function fn() {}
      fn.prototype = obj
      return new fn()
    }
```

### 高阶函数

+ 函数作为参赛传入
+ 函数作为返回值输出

### AOP面向切面编程

AOP（面向切面编程）的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过“动态织入”的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块

### 函数柯里化Currying

一个currying函数首先会接收一些参数，接收了这些残守之后，该函数并不会立即求职，而是继续返回另一个函数，刚才传入的参数在函数形成闭包中被保存起来。待到函数被真正需要求值时，之前传入的所有参数会被一次性用于求值

### 函数节流

函数被频繁触发，而我们不需要它那么高频的触发，所以我们要使它节流，就是把触发频率变低，变为我们规定的一定时间内触发一次。

```javascript
  window.onload = function () {
    let throttle = function (fn, interval = 500) {
      let selt = fn // 存储函数
      let isFirst = true //是否为第一次触发
      let timer = null
      return function (...args) {
        let context = this
        if (isFirst) {
          fn.apply(context, args)
          isFirst = false
          return
        }
        if (timer) {
          return
        } else {
          timer = setTimeout(() => {
            fn.apply(context, args)
            clearTimeout(timer)
            timer = null
          }, interval);
        }
      }
    }
    function onsizeFn() {
      console.log(this, 'onsizeFn');
    }
    function ThrottleOnsizeFn() {
      console.log(this, 'ThrottleOnsizeFn');
    }
    let mydiv = document.getElementById('mydiv')
    for (let index = 0; index < 100; index++) {
      let div = document.createElement('div')
      div.innerHTML = `这是第${index}个div`
      mydiv.appendChild(div)
    }
    window.addEventListener('resize', onsizeFn)
    window.addEventListener('resize', throttle(ThrottleOnsizeFn))
  }
```



## 2.单例模式

### 理解：

> 使用一个变量来标记当前是否已经为某个类创建过对象，如果是，则在下一次获取该类的实例时，直接返回之前创建的对象

### 透明的单例模式

```javascript
  var creatDiv = (
    function () {
      var instance ;
      var creatDiv = function (html) {
        if (instance) {
          return instance
        }
        this.html = html
        return instance = this
      }
      return creatDiv
    }
  )()
  var a = new creatDiv('span1')
  var b = new creatDiv('span2')
  console.log(a===b);
```

利用闭包把首次创建的实例instance保存起来。再利用new 操作符的作用把instance指向首次创建的对象实例指向。

缺点：每次创建一个单例都需要修改其中的createDiv函数。这就与业务耦合一起了

### 用代理实现单例模式

```javascript
  // 单例代理器
  var proxySingleton = function (classFn) {
    var instance;
    return function () {
      if (!instance) {
        instance = new classFn(...arguments);
      }
      return instance;
    };
  };
  // 业务函数
  function animal(name) {
    this.name = name;
  }
  // 创建单例函数
  var singletonAnimal = proxySingleton(animal);
  var a = new singletonAnimal('牛')
  var b = new singletonAnimal('牛')
  console.log(a,a===b);
```

使用单例代理器生成和业务函数，生成一个业务的单例函数。实现与业务的解耦

### 惰性单例

> 需要的时候才创建对象实例，称为惰性单例

```javascript
  // 惰性单例
  var getSingle = function (classFn) {
    var result;
    return function () {
      return result || (result = classFn.apply(this, arguments));
    };
  };
  // 业务函数
  function animal(name) {
    this.name = name;
  }
  function robot(name) {
    this.name = name;
  }
  // 创建单例函数
  var singletonAnimal = getSingle(animal);
  var singletonRobot = getSingle(robot);
  var a1 = new singletonAnimal("牛");
  var b1 = new singletonAnimal("牛");
  var a2 = new singletonAnimal("机器牛");
  var b2 = new singletonAnimal("机器牛");
  console.log(a1, a1 === b1);
  console.log(a2, a2 === b2);
```

## 3.策略模式

> 定义：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。将算法的使用和算法的实现分离开来。
>
> 一个基于策略模式的程序至少由两部分组成。第一部分是一组策略类，策略类封装了具体的算法，并且负责具体的计算过程。第二个部分是环境类Context，Context接收客户的请求，随后把请求委托给某个策略类。要做到这点，Context中要维持某个策略对象的引用。

### 面向对象的策略模式

```javascript
  // 一个按评级，发放不同奖金的业务
  var calculateBonus = function (performanceLevel, salary) {
    if (performanceLevel === "A") {
      return salary * 4;
    }
    if (performanceLevel === "B") {
      return salary * 3;
    }
    if (performanceLevel === "C") {
      return salary * 2;
    }
    if (performanceLevel === "D") {
      return salary * 1;
    }
  };
  // 以后有更多的A+,A-这些级别的业务需求时。我们需要不断的修改这个calculateBonus函数。这将违背了我们的放封闭原则

  // 使用策略模式-1，封装策略类
  class performanceA {
    calculate(salary) {
      return salary * 4;
    }
  }
  class performanceB {
    calculate(salary) {
      return salary * 3;
    }
  }
  class performanceC {
    calculate(salary) {
      return salary * 2;
    }
  }
  class performanceD {
    calculate(salary) {
      return salary * 1;
    }
  }

  // 定义奖金类Bonus
  class Bonus {
    constructor() {
      this.salary = null;
      this.strategy = null;
    }
    setSalary(salary) {
      this.salary = salary;
    }
    setStrategy(strategy) {
      this.strategy = strategy;
    }
    getBonus() {
      return this.strategy.calculate(this.salary);
    }
  }

  // 使用
  var bonus = new Bonus();
  bonus.setStrategy(new performanceA());
  bonus.setSalary(4000);
  console.log(bonus.getBonus());
```

> 定义一系列的算法，把它们各自封装成策略类`performanceA`，算法被封装再策略类内部的方法里`calculate`。在客户对context(一个`new Bonus`)发起请求时，context总是把这个请求委托给这些策略对象中间的某一个进行计算 performance类中的`calculate`函数

### `javacsript`终端策略模式

```javascript
  var strategies = {
    A: function (salary) {
      return salary * 4;
    },
    B: function (salary) {
      return salary * 3;
    },
    C: function (salary) {
      return salary * 2;
    },
    D: function (salary) {
      return salary * 1;
    },
  };
  function calculateBonus(performanceLevel, salary) {
    return strategies[performanceLevel](salary);
  }
  console.log(calculateBonus("A",200));
```

> 这种对象函数的形式使得策略模式在JavaScript中体现的更为简洁。
>
> 策略模式，总的说也是为了取消程序中的if分支，使得策略可以复用替换，而context更为关注自身的私有属性。

#### 策略模式的优缺点

优点：

+ 策略模式利用组合、委托和多态等技术和思想，可以有效避免多重条件选中语句
+ 策略模式提供了对开发-封闭原则的完美支持，将算法封装在独立的strategy中，是的它们易于切换，易于理解，易于扩展
+ 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作
+ 在策略模式中利用组合和委托来让context拥有执行算法的能力，这样也是集成的一种更轻便的替代方法

缺点：

+ 策略模式增加了需要策略类跟策略对象
+ 使用策略模式必须了解所以的strategy，懂得其中的不同点，可以复用点

## 4.代理模式

> 当客户不方便直接访问一个对象或者不满足需要的时候，提供一个替身对象来控制对这个对象的访问，客户实际上访问的是替身对象。替身对象对请求做出一些处理后，再把请求转交给本体对象

### 保护代理和虚拟代理

保护代理：用于控制不同权限对象对目标对象的访问。

虚拟代理：提供一个虚拟对象，节省程序的开销，等真正需要执行时，虚拟代理再把这些操作提供给真实对象

虚拟代理实现突破预加载

```javascript
  // 创建一个真实的img
  var myImage = (function () {
    var imgNode = document.createElement("img");
    document.body.appendChild(imgNode);
    return {
      setSrc: function (src) {
        imgNode.src = src;
      },
    };
  })();
  // 使用虚拟代理
  var proxyImage= (function () {
    var img =  document.createElement("img");
    var src ;
    img.onload = function(){
      // 虚拟对象先假装src图片。在加载完成后，修改正真图片元素的src，由于网络缓存，不需要重复的网络开销
      myImage.src =  this.src
    }
    return {
      setSrc:function(src){
        myImage.src('这是一张loading图片！.png')
        img.src = src
      }
    }
  })()
  proxyImage.setSrc('我要展示这个图片.png')
```

### 单一职责原则

> 就一个类（包括对象和函数等）而言，应该仅有一个引起它变化的原因。如果一个对象程度了多项职责，就意味着这个对象将变得巨大，引起它变化的原因可能会有多个。
>
> 面向对象设计鼓励将行为分布到细粒度的对象之中，如果一个对象程度的职责过多，等于吧这些职责耦合到了一起，这种耦合会导致脆弱和低内聚的设计，当变化发生是，设计肯会遭遇意外的破坏。

### 缓存代理

> 可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果

缓存代理乘积函数

```javascript
  // 乘积函数
  function mult() {
    console.log("开始乘积运算");
    var a = 1;
    for (let index = 0; index < arguments.length; index++) {
      const element = arguments[index];
      a = a * element;
    }
    return a;
  }
  // 使用闭包对乘积函数进行缓存代理
  var proxyMult = (function () {
    var cache = {};
    return function () {
      var args = Array.prototype.join.apply(arguments);
      if (args in cache) {
        return cache[args];
      }
      return (cache[args] = mult.apply(this, arguments));
    };
  })();
  console.log(proxyMult(1,2,3,4,5));
  console.log(proxyMult(1,2,3,4,5));
```

缓存代理工厂

```javascript
var createProxyFactory = function(fn){
  var cache = {}
  return function(){
    var args = Array.prototype.join.apply(arguments)
    if(args in cahe){
      return cache[args]
    }
    return (cache[args] = fn.apply(this,arguments))
  }
}
var proxyMult = createProxyFactory(mult)
```

### 总结

代理分为很多种，而`javascript`开发中最常用的是虚拟代理和缓存代理。

虽然这些代理模式非常有用，但我们写业务代码时，往往不需要预先猜测是否需要使用代理模式。当正真发现不方便直接访问某个对象时，再编写代理也是可行的。

